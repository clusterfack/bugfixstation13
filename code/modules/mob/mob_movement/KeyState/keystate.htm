<html>
<head><title>KeyState documentation</title></head>
<body>
<font size=+2>KeyState</font>
<br>The keyboard and client information library by Loduwijk
<br><br>
<font size=+1>Description</font>
<br><br>
This library can be easily set up to give your client KeyUp and KeyDown functions. If that
is all you need it for and wish to skip the short description of everything else, skip to
the setting up section.
<br><br>
KeyState's main attraction is the KeyUp and KeyDown functions added to the client object.
This allows you to perform actions based on when the player presses and releases keys
instead of trying to perform hacky workarounds for the current, default key repeat process.
The ability to determine the coordinates of the mouse pointer relative to the upper-left
corner of the player's monitor is also included.
<br><br>
Use of the KeyUp and KeyDown functions does not only provide a different way to process commands, but it also allows players to use multiple commands simultaneously. For instance, are you making a side-scrolling platformer and are frustrated that you cannot jump while running? Now you can.
<br><br>
KeyState also includes several new variables for clients that let you detect the client's resolution, color depth and operating system.
<br><br>
This library relies on invisible browser popups that do this work. For the key processing, this means that the invisible window must have the keyboard focus. The key processing window loses focus if the player clicks on the Dream Seeker window and sometimes when switching back from a different window entirely. This is easily fixed with the functions
keystate_focus and KeyFocus listed below.
<br><br>
<font size=+1>Using the Demonstration</font>
<br><br>
The demo includes two parts, both usable at the same time. After opening and logging into the demo world, here are the commands.
<br><br>
-Space Bar: Hold to pull the plunger. Release after holding to let it snap back and strike the
pinball.
<br>-Left: Walk to the left.
<br>-Right: Walk to the right.
<br>-Up: Jump. Hold down longer to jump higher, up to the maximum jump height.
<br><br>
<font size=+1>Using the Library</font>
<br><br>
<b>Setting up</b>
To set up for use of the KeyUp and KeyDown functions quickly and easily, you must call the KeySetup function. That sets up the KeyState object and opens the invisible key processing window, readying it all for use.
<br><br>
Whenever you want to refocus the key processing window, you can call KeyFocus. I usually do this in the client's directional functions, or in the client's Move function if I will not be using that for anything else.
<br><pre>
Example:
client/New()
	.=..()
	KeySetup()</tt>
<br></pre>
After that, you can use KeyDown and KeyUp normally. See the section on using using KeyDown andKeyUp to learn how to use them. See the section on refocusing the key processing window foradvice on when and why you might want to refocus it.
<br><br>
<b>The KeyState object</b>
The KeyState object is the part that keeps track of keyboard information and tells the
client when to use KeyDown and KeyUp.
<br><br>
The KeyState object has six variables.
<br>-client: This references the client for which it works.
<br>-shift: This keeps track of whether or not shift, ctrl and alt are held down.
<br>-key: This keeps track of what keys are down and which are up.
<br>-key_repeat: This determines whether to continue calling KeyDown at the key repeat rate. Itdefaults to false.
<br>-mouse_x/mouse_y: This is the coordinates of the mouse pointer relative to the top-left ofthe monitor. You must call MouseUpdate whenever you want to update these variables.
<br><br>
The KeyState object has three functions.
<br>-Update: This is used by the library to process keystrokes and decide whether or not to
call KeyDown or KeyUp.
<br>-open: This calls the client's KeyFocus function and sets the client's manual_focus to
true. Note that, if for some reason multiple KeyState objects reference the same client or
the client otherwise does not reference this KeyState object, the key information will not besent to this KeyState object.
<br>-close: Gives focus back to the DreamSeeker window and sets the client's manual_focus to false, effectively turning off the key processing ability of this library.
<br><br>
<b>New functions and variables for the client</b>
<br><br>
The client has six new variables.
<br>-keystate: This references the keystate object currently used for key processing. This must be set to a new KeyState object before any key processing can be done.
<br>-resolution: This is the client's monitor resolution, in the form "[WIDTH]x[HEIGHT]"
<br>-avail_resolution: This is the amount of usable space on the client's monitor.
<br>-color_quality: This is the quality of color the client's monitor is set to handle.
<br>-system_type: This is the operating system the client is using.
<br>-key_repeat: This determines whether to call KeyDown once when it is held, or to call it multiple times at the client's keyboard repeat rate. True executes KeyDown at key repeat rate. Defaults to 0.
<br>-manual_focus: If false, does not allow use of the manual_focus verb. Defaults to 1
<br><br>
The client has eleven new functions.
<br>-avail_resolution: returns available resolution
<br>-color_quality: returns color depth
<br>-KeyDown: This is called when the client presses down a key.
<br>-KeyUp: This is called when the client lets a pressed key up.
<br>-KeySetup: This references the keystate variable to a new KeyState object and readies it for use by calling KeyFocus.
<br>-KeyFocus: This refocuses the key processing window.
<br>-key_repeat: sets key_repeat availability
<br>-MouseUpdate: This updates the screen_x and screen_y variables of the client's KeyState
object.
<br>-InfoUpdate: This gets the resolution, avail_resolution, color_quality and system_type
information.
<br>-manual_focus: This is a hidden verb clients can use to regain the key process window's
focus.
<br>-resolution: returns client's resolution
<br>-system_type: returns text string telling what the client's operating system is
<br><br>
avail_resolution, color_quality, resolution and system_type all require the InfoSetup function to be called before they can be used. You can do this in client/New, however it doesn't work sometimes if called too early.
<br><br>
This library also has a number of constants for your use in identifying key codes.
<br><pre>
Example:
client
	New()
		.=..()
		KeySetup()
	KeyDown(KeyCode,shift)
		if(KeyCode == KS_Q && shift&KS_SHIFT_CTRL)
			if(alert(src,"Are you sure you want to quit?","Quit? Yes/No","Yes","No")=="Yes")
				mob.Logout()</tt>
<br></pre>
<font size=+1>When and why to Refocus the Key Processor</font>
<br><br>
Since the invisible popup needs to retain focus in order for the bulk of this library to work,and the players cannot click on something that is invisible, there is a verb built in thatlets the client refocus it themselves (The verb can be disabled by you.) However, you willprobably want to refocus it automatically to make it easy on your players. After all,
nobody wants to have to type in a command when that end boss is pounding on them. This can be done easily using the client's KeyFocus function.
<br><br>
If you are using the KeyUp and KeyDown functions to control movement, then you no longer needthe client's directional functions (North(), South(), etc.) As such, it makes sense to start there, making them all do nothing but call KeyFocus. Then, when your player holds down the arrow key to move, it will automatically refocus and begin moving as normal with only a moment delay. If your movement system does not use the client's Move function, that makes it even easier on you. One line of code, "client/Move()KeyFocus()" does it all.
<br><br>
As for when the focus might be lost, one culprit is clicking the window. Therefor, there is
another trick you can use to avoid losing focus. The players will probably be clicking either the map or a verb. You can call client.KeyFocus() at the end of verbs and/or at the end of Click functions, then they can click and focus gets returned immediately for no interruption.
<br><br>
On the other hand, you may want to provide a key that shifts focus back away from the key processor for times when the player needs to type a command. For this, you can use the KeyState object's close function.
<br><br>
On that note, remember that the player's will probably want to type some things in when you get the idea in your head to just call KeyFocus inside an infinite loop every few seconds; as that would hinder the typing.
<br><br>
A tip: A macro to toggle the focus makes it easier than having to click on the window then type the focusing verb.
<br><br>
<font size=+1>KeyState Library Dictionary</font>
Variables and functions all together in alphabetical order and a list of the constants.
<br><br>
This section links to the variables and functions needed and provides more detailed informationfor some of them.
<br><br>
<b>Variables</b><pre>
avail_resolution (client)
client (KeyState)
color_quality (client)
key (KeyState)
	Straightforward list, each index used for the KeyCode of the same number.
	1 means the key is down, 0 means the key is up
key_repeat (KeyState)
keystate (client)
manual_focus (client)
mouse_x (KeyState)
mouse_y (KeyState)
resolution (client)
shift (KeyState)
	Keeps track of whether shift, ctrl and alt are down. The following bit flags are used.
	KS_SHIFT_SHIFT
	KS_SHIFT_CTRL
	KS_SHIFT_ALT
system_type (client)</pre>
<br><br>
<b>Functions</b><pre>
avail_resolution (client)
close (KeyState)
color_quality (client)
InfoUpdate (client)
keycode2char
	keycode2char(KeyCode)
		keycode2char returns a text string with the character corresponding to the key code
KeyDown (client)
	KeyDown(KeyCode, shift)
		KeyCode is the number that corresponds to the key pressed
		shift keeps track of which keys, between shift, ctrl and alt are held down
KeyFocus (client)
KeySetup (client)
KeyUp (client)
	KeyUp(KeyCode, shift)
		Same as KeyDown, except it is called when the key is released.
manual_focus (client)
	This is a verb.
MouseUpdate (client)
open (KeyState)
resolution (client)
system_type (client)
update (KeyState)</pre>
<br><br>
<b>Constants</b><pre>
KS_SHIFT_SHIFT	1
KS_SHIFT_CTRL	2
KS_SHIFT_ALT	4

KS_BACKSPACE 8
KS_TAB		9

KS_NUM_CENTER	12

KS_ENTER	13

KS_SHIFT	16
KS_CTRL		17
KS_ALT		18

KS_BREAK	19

KS_CAPSLOCK	20
KS_ESCAPE	27

KS_SPACE	32

KS_PAGEUP	33
KS_PAGEDOWN	34
KS_END		35
KS_HOME		36

KS_LEFT		37
KS_UP		38
KS_RIGHT	39
KS_DOWN		40

KS_INSERT	45
KS_DEL		46

KS_0		48
KS_1		49
KS_2		50
KS_3		51
KS_4		52
KS_5		53
KS_6		54
KS_7		55
KS_8		56
KS_9		57

KS_A		65
KS_B		66
KS_C		67
KS_D		68
KS_E		69
KS_F		70
KS_G		71
KS_H		72
KS_I		73
KS_J		74
KS_K		75
KS_L		76
KS_M		77
KS_N		78
KS_O		79
KS_P		80
KS_Q		81
KS_R		82
KS_S		83
KS_T		84
KS_U		85
KS_V		86
KS_W		87
KS_X		88
KS_Y		89
KS_Z		90


KS_NUM_0	96
KS_NUM_1	97
KS_NUM_2	98
KS_NUM_3	99
KS_NUM_4	100
KS_NUM_5	101
KS_NUM_6	102
KS_NUM_7	103
KS_NUM_8	104
KS_NUM_9	105
KS_NUM_ASTERISK	106
KS_NUM_ADD		107
KS_NUM_SUBTRACT	109
KS_NUM_PERIOD	110
KS_NUM_SLASH	111

KS_F1	112
KS_F2	113
KS_F3	114
KS_F4	115
KS_F5	116
KS_F6	117
KS_F7	118
KS_F8	119
KS_F9	120
KS_F10	121
KS_F11	122
KS_F12	123

KS_NUM_LOCK		144
KS_SCROLL_LOCK	145

KS_COLON	186
KS_EQUAL	187
KS_COMMA	188
KS_SUBTRACT	189
KS_PERIOD	190
KS_SLASH	191
KS_BACK_APOSTROPHE 192

KS_OPEN_BRACKET	219
KS_BACKSLASH	220
KS_CLOSE_BRACKET 221
KS_APOSTROPHE	222
</pre>
</body>
</html>